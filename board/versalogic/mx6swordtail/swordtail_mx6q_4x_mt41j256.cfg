/*
 * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
 * Jason Liu <r64343@freescale.com>
 *
 * SPDX-License-Identifier:	GPL-2.0+
 *
 * Refer doc/README.imximage for more details about how-to configure
 * and create imximage boot image
 *
 * The syntax is taken as close as possible with the kwbimage
 */

#define __ASSEMBLY__
#include <config.h>
/* image version */
IMAGE_VERSION 2

/*
 * Boot Device : one of spi, sd, sata
 * the board has no nand and eimnor
 * spinor: flash_offset: 0x0400
 * sata:   flash_offset: 0x0400
 * sd/mmc: flash_offset: 0x0400
 */

/* the same flash_offset as sd */
BOOT_FROM     spi

/*
 * Device Configuration Data (DCD)
 *
 * Each entry must have the format:
 * Addr-type           Address        Value
 *
 * where:
 *      Addr-type register length (1,2 or 4 bytes)
 *      Address   absolute address of the register
 *      value     value to be stored in the register
 */
/* Set pinmux and drivers that need to be controlled from the beginning */
// IOMUXC_SW_PAD_CTL_PAD_EIM_DATA22 (USB_OTG_PWREN)
DATA 4 0x020e03bc 0x000030b0 // pull-down to disable from start
// IOMUXC_SW_PAD_CTL_PAD_GPIO01 (USB_OTG_ID)
DATA 4 0x020e05f4 0x00010759 // disable pull res from start
// IOMUXC_SW_MUX_CTL_PAD_GPIO01 (USB_OTG_ID)
DATA 4 0x020e0224 0x00000003 // pinmux selects USB_OTG_ID pin

// IOMUXC_SW_PAD_CTL_PAD_NAND_CS2_B (LVDS_BKLTEN)
DATA 4 0x020e06d4 0x00013018 // pull-down to disable from start

// IOMUXC_SW_PAD_CTL_PAD_SD3_DATA4 (BT_ENABLE)
DATA 4 0x020e069c 0x00003029 // pull-down, 50 Ohms @ 1.8V driver 
// IOMUXC_SW_PAD_CTL_PAD_SD3_DATA5 (WIFI_ENABLE)
DATA 4 0x020e0698 0x00003029 // pull-down, 50 Ohms @ 1.8V driver 
// IOMUXC_SW_PAD_CTL_PAD_SD3_RESET (WIFI_HOST_WAKE)
DATA 4 0x020e06b8 0x00013068 // pull-down, 50 Ohms @ 1.8V driver 
// IOMUXC_SW_PAD_CTL_PAD_SD3_DATA6 (BT_HOST_WAKE)
DATA 4 0x020e0694 0x00013068 // pull-down, 50 Ohms @ 1.8V driver 
// IOMUXC_SW_PAD_CTL_PAD_SD3_DATA7 (BT_DEVICE_WAKE)
DATA 4 0x020e0690 0x00013068 // pull-down, 50 Ohms @ 1.8V driver 

// IOMUXC_SW_PAD_CTL_PAD_KEY_COL0 (CELL_PWRON)
DATA 4 0x020e05c8 0x00010898	// open drain with no pull resistor

/* Set up memory control and drivers */
// IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE = DDR3 (bits 19:18 = 11)
DATA 4 0x020e0798 0x000C0000
// IOMUXC_SW_PAD_CTL_GRP_DDRPKE = disable pull/keep (bit 12 = 0)
DATA 4 0x020e0758 0x00000000 /* Default is 0x0001000 */ 
// IOMUXC_SW_PAD_CTL_DRAM_SDCLK0_P set with DSE = 48 Ohms
DATA 4 0x020e0588 0x00008028
// IOMUXC_SW_PAD_CTL_DRAM_SDCLK1_P set to disable driver (Hi-z)
DATA 4 0x020e0594 0x00008000
// IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_B set with DSE = 48 Ohms
DATA 4 0x020e056c 0x00008028
// IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_B set with DSE = 48 Ohms
DATA 4 0x020e0578 0x00008028
// IOMUXC_SW_PAD_CTL_GRP_ADDDS set with DSE = 48 Ohms
DATA 4 0x020e074c 0x00000028
// IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET set with DSE = 48 Ohms
DATA 4 0x020e057c 0x00003028
// IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 everything disabled
// Note: DSE is set by IOMUXC_SW_PAD_CTL_GRP_CTLDS below
DATA 4 0x020e058c 0x00000000 /* this just gets cleared out */
// IOMUXC_SW_PAD_CTL_PAD_DRAM_ODT0 set with DSE = 48 Ohms
DATA 4 0x020e059c 0x00003028
// IOMUXC_SW_PAD_CTL_PAD_DRAM_ODT1 set to disable driver (Hi-z)
DATA 4 0x020e05a0 0x00003000
// IOMUXC_SW_PAD_CTL_GRP_CTLDS set to DSE = 48 Ohms
DATA 4 0x020e078c 0x00000028

// IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 
/* bit 17 SDQS_P[7:0] DDR_INPUT (1 = Differential 50% threshold)*/
DATA 4 0x020e0750 0x00020000 /* tried the CMOS setting but it failed, so keep differential */

/* Next 8 are DQS_P settings, DSE = 48 Ohms */
// IOMUXC_SW_PAD_CTL_PAD_SDQS[0:7]_P
DATA 4 0x020e05a8 0x00002028
DATA 4 0x020e05b0 0x00002028
DATA 4 0x020e0524 0x00002028
DATA 4 0x020e051c 0x00002028
DATA 4 0x020e0518 0x00002028
DATA 4 0x020e050c 0x00002028
DATA 4 0x020e05b8 0x00002028
DATA 4 0x020e05c0 0x00002028

// IOMUXC_SW_PAD_CTL_GRP_DDRMODE
/* bit 17 DATA [63:0] DDR_INPUT (0 = CMOS)*/
DATA 4 0x020e0774 0x00000000 /* setting to CMOS passes (like Zebra, for power savings) */

// IOMUXC_SW_PAD_CTL_GRP_B[0:7]DS
// Set DSE for byte groups to 48 Ohms
DATA 4 0x020e0784 0x00000028
DATA 4 0x020e0788 0x00000028
DATA 4 0x020e0794 0x00000028
DATA 4 0x020e079c 0x00000028
DATA 4 0x020e07a0 0x00000028
DATA 4 0x020e07a4 0x00000028
DATA 4 0x020e07a8 0x00000028
DATA 4 0x020e0748 0x00000028

DATA 4 0x020e0790 0x000C0000
DATA 4 0x020e07AC 0x00000100

// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM[0:7]
// Set DSE for byte groups to 48 Ohms
DATA 4 0x020e05ac 0x00008028
DATA 4 0x020e05b4 0x00008028
DATA 4 0x020e0528 0x00008028
DATA 4 0x020e0520 0x00008028
DATA 4 0x020e0514 0x00008028
DATA 4 0x020e0510 0x00008028
DATA 4 0x020e05bc 0x00008028
DATA 4 0x020e05c4 0x00008028

/* MMDC Register Set (DDR3 controller specific settings) */

// MMDC1_MDSCR (this setting covers both channels for DDR3)
// Request to configure MMDC is valid setting
DATA 4 0x021b001c 0x00008000

// MMDCx_MPZQHWCTRL register for ZQ calibrations
/* Enables both one-time and periodic HW ZQ calibration (ZQ_MODE SET TO 0x3) for both DRAM channels */
DATA 4 0x021b0800 0xA1390003

/**** The following are memory calibration result values. */
/* Per Swordtail 0.10A Quad calibration (2GB) 10/17/2018 */
// Write Leveling Delay Controls ----------
/* MMDC1_MPWLDECTRL0 register for byte1 and byte0 */
DATA 4 0x021b080c 0x0051005A
/* MMDC1_MPWLDECTRL1 register for byte3 and byte2 */
DATA 4 0x021b0810 0x005E0054
/* MMDC2_MPWLDECTRL0 register for byte5 and byte4 */
DATA 4 0x021b480c 0x00290042
/* MMDC2_MPWLDECTRL1 register for byte7 and byte6 */
DATA 4 0x021b4810 0x00190023
// Read DQS Gating Controls ---------------
/* MMDC1_MPDGCTRL0 for PHY0 */
DATA 4 0x021b083c 0x441C0424
/* MMDC1_MPDGCTRL1 for PHY0 */
DATA 4 0x021b0840 0x037C037C
/* MMDC2_MPDGCTRL0 for PHY1 */
DATA 4 0x021b483c 0x437C0404
/* MMDC2_MPDGCTRL1 for PHY1 */
DATA 4 0x021b4840 0x0354032C
// Read Delay-lines Controls --------------
/* MMDC1_MPRDDLCTL for PHY0 */
DATA 4 0x021b0848 0x4A404446
/* MMDC2_MPRDDLCTL for PHY1 */
DATA 4 0x021b4848 0x46443C50
// Write Delay-lines Controls -------------
/* MMDC1_MPWRDLCTL for PHY0 */
DATA 4 0x021b0850 0x38343A3A
/* MMDC2_MPWRDLCTL for PHY1 */
DATA 4 0x021b4850 0x48324840

// MMDCx_MPRDDQBY[0:3]DL (fine read delays - not adjusted)
DATA 4 0x021b081c 0x33333333
DATA 4 0x021b0820 0x33333333
DATA 4 0x021b0824 0x33333333
DATA 4 0x021b0828 0x33333333
DATA 4 0x021b481c 0x33333333
DATA 4 0x021b4820 0x33333333
DATA 4 0x021b4824 0x33333333
DATA 4 0x021b4828 0x33333333
// MMDCx_MPMUR0 (measure unit - not adjusted)
DATA 4 0x021b08b8 0x00000800
DATA 4 0x021b48b8 0x00000800

// Begin MMDC initialization now
DATA 4 0x021b0004 0x00020036
DATA 4 0x021b0008 0x09444040
DATA 4 0x021b000c 0xB9BE79A5 // adjusted for 8Gbit device support, tclk = 1.89ns
DATA 4 0x021b0010 0xFF738F64 // adjusted for 8Gbit devices support, tclk = 1.89ns
DATA 4 0x021b0014 0x01FF00DD // adjusted for 8Gbit devices support, tclk = 1.89ns
// WALAT=1 setting adjustment per Calibration, RALAT=5
DATA 4 0x021b0018 0x00011740
// Request to configure MMDC is valid setting
DATA 4 0x021b001c 0x00008000
DATA 4 0x021b002c 0x000026d2
// Matched up to Zebra value
DATA 4 0x021b0030 0x008F1023
// MMDCx_MDASP CS0_END (27 for 1GB, 47 for 2GB, 7F for 4GB)
DATA 4 0x021b0040 0x00000047 
// MMDCx_MDCTL register
/* 512Mx16 devices have 16 row address bits, use 0x851A0000 */
/* 256Mx16 devices have 15 row address bits, use 0x841A0000 */
/* 128Mx16 devices have 14 row address bits, use 0x831A0000 */
// enable CS0, 15-bit row/10-bit column addr, 64-bit data 
DATA 4 0x021b0000 0x841A0000
// Mode Register writes for CS0 memories (using only CS0)
DATA 4 0x021b001c 0x04088032
DATA 4 0x021b001c 0x00008033
DATA 4 0x021b001c 0x00048031
DATA 4 0x021b001c 0x09408030
DATA 4 0x021b001c 0x04008040
// tREFI = 3.9us
DATA 4 0x021b0020 0x00007800 
// Channel 0 ODT (0 ohms) in imx6, 120 ohms in devices 
DATA 4 0x021b0818 0x00000007
// Channel 1 ODT (0 ohms) in imx6, 120 ohms in devices 
DATA 4 0x021b4818 0x00000007
// Power Down settings -- enable self-refresh when idle
DATA 4 0x021b0004 0x00025576
DATA 4 0x021b0404 0x00011006
DATA 4 0x021b001c 0x00000000 // Initialization is complete

/* set the clock gate settings to save power (11 = enable) */
DATA 4 0x020c4068 0x00C03F3F
DATA 4 0x020c406c 0x0030FC03
DATA 4 0x020c4070 0x0FFFC000
DATA 4 0x020c4074 0x3FF00000
DATA 4 0x020c4078 0x0000F300 // pwm clocks off, pcie clock off
DATA 4 0x020c407c 0x0F0000C3
DATA 4 0x020c4080 0x0000FFF9 // gate usdhc1

// IOMUXC_GPR4
/* enable AXI cache for VDOA/VPU/IPU */
DATA 4 0x020e0010 0xF00000CF
// IOMUXC_GPR6
/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
DATA 4 0x020e0018 0x007F007F
// IOMUXC_GPR7
DATA 4 0x020e001c 0x007F007F

/*
 * Setup CCM_CCOSR register as follows:
 *
 * cko1_en  = 1	   --> CKO1 enabled (bit 7)
 * cko1_div = 111  --> divide by 8  (bits 6:4)
 * cko1_sel = 1011 --> ahb_clk_root (bits 3:0)
 * clear all settings for CCM_CLKO2 (disable) 
 *
 * This sets CCM_CLKO1 (audio clock) at ahb_clk_root/8 = 132/8 = 16.5 MHz
 * Audio CODEC (SYS_MCLK) works with any clock between 8.0 and 27MHz.  
 */
// CCM_CCOSR 
/* Audio clock not used, default is 0x000A0001 */
DATA 4 0x020c4060 0x000A0001  /* Disables both clock outputs */
